# 阿里百秀

### 1.提取公共部分

静态页面修改为动态页面的时候，记得修改路径

如果某段代码内容需要在多个php文件中使用时，可以使用一个独立的php文件进行保存，在需要使用这个内容的php文件中进行引入操作即可

- PHP中的文件引入操作

require - 需要 - 必须

include - 包含 - 非必须

- 两种引入方式的区别

> require引入文件时如果失败，后续程序无法执行。
>
> include引入文件时如果失败，后续程序可以继续执行

- 使用场景

require通常用于引入一些必须的数据值，例如，数据库的地址、用户名、密码

include通常用于引入页面的公共区域使用，设置网页结构时的基本原则：确保网页可以最大程度的显示

- 另外两种引入方式

require_once的基本使用方式与require相同，但是只能引入一次，再次使用会被忽略。

include_once的基本使用方式与include相同，但是只能引入一次，再次使用会被忽略。

- 小结

只要进行数据操作，使用require_once；只要进行页面操作，使用include_once



### 2.防止非法访问文件问题

有些页面的数据是根据点击的ID来动态获取数据，然后进行渲染，如果直接访问此页面的话会没有数据，所以要进行判断

```php
if(!isset($_GET['id'])) {
  header('Location:index.php')
}
```

提交数据的时候，要进行数据的判断，是否有此数据，虽然客户端进行过验证，但是因为客户端是可以被修改的，所以不太安全，要在服务端再一次判断

```php
if (!isset($_GET['id']) || !isset($_GET['name']) || !isset($_GET['slug'])) {
	echo '失败';
	return;
}
```



### 3.sql有关

#### 多表联合查询

```sql
select  posts.id,posts.title,posts.feature,posts.likes,categories.name,users.slug from posts
    inner join categories on posts.category_id=categories.id
    inner join users on posts.user_id=users.id
    where categories.id=$id
    order by posts.created desc
    limit 10";
```

#### 批量删除

```sql
单个设置时使用的是：where id=2
多个设置时可以使用：where id in (1,2,3,4,5)
单个设置也同样适用： where id in (1)
前台可以把所有需要删除的数据ID放在一个数组中传递过来
delete from categories where id in ($id);
```

#### 筛选功能

因为筛选功能两个条件都是可选的，而且前后的顺序并不确定，所以sql语句可以先默认设置一个恒等式，然后and拼接

```php
$where = 'where 1=1 '; // 为了避免出现错误
//	- 分类参数检测和条件设置
if (isset($_GET['category']) && $_GET['category'] !== 'all') {
	$where .= ' and posts.category_id=' . $_GET['category'];
}

//  - 状态参数检测和条件设置
if (isset($_GET['status']) && $_GET['status'] !== 'all') {
	$where .= " and posts.status='{$_GET['status']}'";
}
```

#### 查询数据条数

```sql
select count(1) as num from posts
```



### 4.php与HTML进行拼接

```php
foreach ($result as $val) {
        // 将结构中的内容使用$val中对应的数据替换即可
        echo '<li><a href="/list.php?id=' . $val['id'] . '"><i class="fa ' . $val['classname'] . '"></i>' . $val['name'] . '</a></li>';
      }
// 使用.拼接
```

```php
<?php foreach ($result as $val) { ?>
      <li><a href="/list.php?id=<?php echo $val['id']; ?>"><i class="fa <?php echo $val['classname']; ?>"></i><?php echo $val['name']; ?></a></li>
     <?php } ?>
```

```php
<!-- 以下为指令式的foreach等内容 -->
     <?php // foreach ($result as $val): ?>
     <?php // for (): ?>
     <?php // if (): ?>
     <?php // endif; ?>
     <?php // endfor; ?>
     <?php // endforeach; ?>
```



### 5.后台管理侧边对应高亮

实现原理：每个引入当前公共区域文件的页面中都声明了一个page变量，可以在当前页面中检测本页面是哪一个，设置对应的高亮显示效果即可

如果此菜单下面还有多个子菜单，那么可以定义一个数组，判断page是否在这个数组中in_array()



### 6.所需要的API

使用ajax进行数据的增删改查操作时，可以设置4个对应的php文件用于进行请求处理，这些页面的功能仅仅用于处理请求，实现对应的功能，不会进行单独的访问操作，这种页面我们也可以将其称为api

API：让编程更方便的一种事物。指定的功能页面：通过对del.php进行请求，可以实现删除指定数据的功能



### 7.分页功能

> 从其他的网站分析功能
>
> ​	核心功能：
>
> ​		上一页和下一页按钮，中间区域显示的可点击的页号(个数随意)
>
> ​	可选功能：
>
> ​		首页和尾页按钮，指定页号跳转



> 需要准备的数据
>
> ​	总页数(总共可以显示的页数,需要计算)
>
> ​	本次获取的数据的条数(数据库操作)
>
> ​	设置每页要显示的数据条数(自己制定合理的数目即可)



用一个变量page来代表页号，因为别的部分也需要操作这个变量，所以可以设为全局变量

因为需要制作分页功能，不仅需要获取文章信息，还需要获取数据的总条数，所以后台传回的数据为借口形式

确定开始页号和结束页号，并做边界检测

删除数据的时候，因为有分页功能，所以出现了新的问题。

- 删除后,只进行了结构删除,如果点击多次,本页的数据就没有20条了
- 删除操作时可能额对页数造成影响(最后一页)，最后一页删除了表格中所有的数据，导致当前总页数减少1

解决方式：

- 删除完了以后可以再次请求数据，进行数据的渲染
- 需要每次删除后,检测当前数据总页数与现在显示的页号之间的关系，如果最大页号改变,并且小于当前显示页号时,修改当前显示页号

sql语句

```sql
 --- 分页功能设置:
limit n  从最前面获取10条
limit n,m 
 - n 检索数据的起始位置
 - m 检测的数据条数
```

#### 分页插件

使用jQuery插件设置分页效果
官网地址: http://josecebe.github.io/twbs-pagination/

```javascript
$list.twbsPagination({
    totalPages : totalPages, // 总页数
    visiblePages : 7, // 可见页数
    onPageClick : function (event, page) {
      
    },
    first : '首页',
    last : '末页',
    next : '下一页',
    prev : '上一页'
});
```



### 8.富文本编辑器

遇到的问题

> 在进行网站数据设置时,经常会遇到大篇幅的文章内容,设置内容时如果使用textarea会导致内容是没有格式的，展示后也不会具有格式,用户查看起来不方便.



富文本编辑器

> 普通文本:没有格式的文本形式
>
> 超文本:具有格式的文本
>
> 富文本:使用普通文本描述超文本的一种方式，可以将一段文本内容设置为富文本的形式.

常见的富文本编辑器：ckeditor,Ueditor

#### ckeditor的使用

```java
官网下载文件
- 引入ckeditor.js和contents.css
- 对某个文本域设置方法CKEDITOR.replace(id名);
  - 通过观察我们发现,调用方法后文本域会被隐藏,并且在原始位置生成了一个富文本编辑器的结构   - 可以通过点击顶部的操作按钮,给我们的内容设置格式 - 将数据提交给服务端的方式:   - 表单提交方式:无脑操作,书写好数据,点击提交按钮即可,数据的name就是文本域的name
  - ajax提交方式:
    - 由于文本域是空的,数据提交后没有对应的数据
    - 可以使用ckeditor的方法进行处理updateElement()
      - 实际上调用方法,可以让富文本编辑器将内部的内容返还给对应的文本域
        - 如果页面中存在多个富文本编辑器的实例时,需要对CKEDITOR.instances属性进行遍历设置
        - 如果确定页面中只存在一个富文本编辑器,可以利用id进行对应访问(没必要遍历了)
```

```javascript
CKEDITOR.instances.content.updateElement(); // 将富文本编辑器的内容返还到文本域中

      // 将表单的数据提交给服务端保存:
      //    - 使用FormData对表单数据进行处理
      //      - FormData()的参数需要为一个DOM对象形式的表单元素
注意： 返还数据要在new FormData()之前！！
```

#### Ueditor

```javascript
调用getEditor方法,设置富文本编辑器
// 参数1:要设置富文本编辑器的元素的id名
// 参数2:用于设置富文本编辑器的配置信息
UM.getEditor('content', {
      initialFrameWidth : '100%',
      initialFrameHeight : 300,
      initialContent : '请输入内容',
      toolbar : ['source | undo redo | bold italic underline strikethrough | superscript subscript | forecolor backcolor | removeformat | insertorderedlist insertunorderedlist | selectall cleardoc paragraph | fontfamily fontsize']
    });

// 使用ajax进行请求发送时,无须处理,只需要将表格的数据进行提交即可,操作较为简便
```



### 9.表单验证插件

jQuery的validate插件

```javascript
validate是一款常用的,用于进行表单验证的jQuery插件
 - 以下内容是对常用的参数进行说明,完整使用方式可以见以下链接:
   - https://www.runoob.com/jquery/jquery-plugin-validate.html
   - https://jqueryvalidation.org/documentation/ 官网地址
```

```javascript
$form.validate({
    rules : {
      // 通过表单元素的name属性,作为规则的指定标识
      email_name : {
        required : true, // 当前元素是否必选
        maxlength : 20,
        minlength : 6,
        email : true // 匹配规则为邮箱验证方式
      },
      password : {
        required : true,
        // 设置密码框时,需要自己定义检测规则
        psw : true
      }
    },
    messages : {
      email_name : {
        required : '必须甜,不甜不行!!!~~~'
      },
      password : {
        required : '需要填写密码',
        psw : '密码格式不对'
      }
    },
    submitHandler : function () {
      console.log('呵呵呵呵呵,就不提交~~~');
    }
  });
```

```javascript
 // 使用以下方式用于设置自定义匹配规则
  //    - 参数1: 规则名称
  //    - 参数2: 规则的检测方式,函数
  //      - 形参1: 当前表单元素内容
  //      - 形参2: 当前表单元素,DOM对象
  //      - 形参3: 设置规则时,给定的属性值(自定义规则时,通常不使用这个参数)
  //    - 参数3: 提示信息
  $.validator.addMethod('psw', function (value, element, params) {
    // 这个函数需要返回布尔类型值,用于决定匹配成功还是失败

    // this.optional(element) 用于检测当前元素是否为必选元素:
    //    - 如果元素为必选:
    //      - 结果恒为false,在逻辑或中,就必须通过后面的检测条件,结果才能为true
    //    - 如果元素为可选:
    //      - 如果没有内容,方法返回一个字符串'dependency-mismatch',转换布尔类型为true,可以避免进行后续检测
    //      - 如果具有内容,结果为false,也只有通过后续检测,结果才能为true

    return this.optional(element) || /^[a-zA-Z0-9]{6,10}$/.test(value);

  }, '不符合密码规则~~~');
```





### 10.保存用户状态

登录成功之后可以通过session记录登录状态，也可以记录用户有关的一些信息

当某个后台页面被访问时,都应当检测当前用户的登陆状态

- 如果登陆,可以继续访问
- 如果没有登陆,跳转到登陆页面
- 为了登陆后可以再跳转到当前页面,可以将当前页面的地址保存到session中
  - $_SERVER['PHP_SELF'] - 用于获取当前页面的路径信息

```php
session_start(); // 使用session前必须先开启session功能
$_SESSION['login_status'] = 'success';
```



### 11.模板引擎

进行动态网站制作过程中,一定会出现许多的结构创建操作,就不可避免的进行字符串拼接.为了减少字符串拼接出错的几率,通常我们都会使用模板引擎进行结构创建操作

```javascript
模板引擎
      - art-template 腾讯
      使用方式:
        - 下载文件
        - 引入文件
        - 找到要设置为模板的结构
        - 设置指定的模板结构: 需要使用script标签,同时将type更改为非js的形式,推荐设置为text/template
          - 将指定的内容填写到内部
        - 在js中调用template()
          - 参数1: 模板的id
          - 参数2: 模板需要使用的数据
          - 返回值: 处理完毕的结构字符串
    官网链接: https://aui.github.io/art-template/zh-cn/index.html
```

```javascript
<script type="text/template" id="template_test">
    {{$data}} // 如果是访问它的属性可以省略它
    
    {{$data.name}}
    {{$data['name']}}
    {{name}}

    {{$data['datas'][0]}}
    {{datas[1]}}
    
    {{if false}}
      <span>这是span</span>
    {{/if}}

    {{each obj val i}}
      自带索引访问方式为:{{$index}}
      自带值访问方式为:{{$value}}
      自定义索引访问方式为:{{i}}
      自定义值访问方式为:{{val}}
    {{/each}}

    <ul>
      <li>这是原样输出的li</li>
      <li>这是原样输出的li</li>
      <li>这是原样输出的li</li>
      <li>这是原样输出的li</li>
    </ul>
  </script>
```



### 12.模块化操作

#### 基本概念

模块：将代码根据功能分为多个部分，每个部分统称为模块

模块化：将代码按照模块进行分隔的一种形式，结构清晰

#### 进行模块化操作的方式

- 利用立即执行函数

给每个独立的功能设置立即执行函数，设置参数，window，document

根据代码实际的功能决定是否在文件中保存；

对每个模块的主题功能设置暴露操作，设置给window的属性

问题：多个模块在引入时需要考虑加载顺序问题；

​	    将功能暴露给window，增加了window中的属性个数

- 模块化工具

  模块化的3种规范

  - AMD  CMD  CommanJS

  CommanJS服务端的模块化规范：nodeJS

  CMD  sea.js

  AMD  require.js

##### 使用require.js

require(), define()

```javascript
- 在引入requirejs的script标签中设置data-main属性
	- data-main的作用：用于设置主模块的文件路径，主模块会被requirejs自动加载
	- 定义模块和引入模块时的默认路径与主模块路径相同
	- 设置的路径默认为.js的后缀
- 使用require()对主模块的依赖关系进行声明
	- 参数1：数组形式，内部填写依赖的模块的文件路径，默认为data-main中的主模块路径，默认为.js后缀
	- 参数2：函数形式，用于保存当前模块的代码
- 使用define()对其他模块进行定义，同时声明依赖关系
	- 参数1(可选)：数组形式，内部填写依赖的模块的文件路径，默认为data-main中的主模块路径，默认为.js后缀
	- 参数2：函数形式，用于保存当前模块的代码
	- 返回值：当前模块的主体功能，引入此模块的其他模块需要在函数中进行接收使用。
	- 如果当前模块不依赖于其他模块，可以不写

```

> 主页面

```javascript
<script src="require.js" data-main="main"></script>
```



> main.js

```javascript
require(['a', 'b'], function (a, b) {
  //用于放置当前模块的主体代码
  console.log('这是main.js的主体功能,还包含a模块的一些功能:(' + a + ')');
})
// 假定的依赖关系，主模块依赖了a和b，a依赖了c
```



> a.js

```javascript
define(['c'], function (c) {
  return '这是a的主题功能'
})
```



> c.js

```javascript
define(function () {
  return '这是c'
})
```

##### 路径问题

实际开发中，被依赖的模块可能不跟main在同一个路径下

require提供了一个方法config进行配置设置,

```javascript
// 如果有其他模块使用标识名称的话也可以生效，统一配置的感觉
require.config({
  baseUrl : 'a/b/c',
  paths : {
    'jquery' : '/afd/adf/aaf/ds/f/jquery',
    'template' : '/ada/fads/fa/df/asdf',
    'bootstrap' : '////',
    'twbsPagination' : '////'
  },
  shim : { //处理不规范的模块
    'twbsPagination' : {
      deps : ['jquery'], //用于声明当前模块的依赖关系
      exports : '$.fn.twbsPagination'  //用于声明当前模块输出的功能
    }
  }
})
```

```javascript
// 设置了paths后，在[]中书写的就是模块的标识名称了
//		- 不符合规范的模块不能像其他模块一样进行引入，需要单独设置
require(['jquery','template','twbsPagination'], function () {
  
})
```



### 13.零碎的东西

```javascript
var statusObj = {
  published : '已发布',
  drafted : '草稿',
  trashed : '已删除'
};
statusObj[datas.status]  //  将对应的英文转换成中文状态
```